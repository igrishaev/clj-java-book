### Sanitizing HTML

Moving on to the second class, we will talk about sanitizing HTML which is a tricky topic. It involves working with XML documents and XPath expression.

The need to sanitize HTML occurs when you fetch it from RSS feeds or parse websites. Or maybe your commenting system allows users to submit their replies flawored with HTML tags. If it's a service for developers, most likely it supports Makrdown which compiles to HTML.

## The problem of raw HTML

Why to filter HTML content? Because if such data comes from a source you cannot trust, there are dozens of ways to attack a user who is about to read it.

Obviosly, the threat number one is `<script>` tags. They can desserve in many ways: mining Bitcoin on you machine, redirecting you to malicious sites, stealing cookies, DDOS'ing somebody, etc.

Sometimes, even CSS styles carry inline Javascript to calculate width of a page for example. Such properties as `background-image` may refer a URL so your browser makes HTTP GET requests. There is no guarantee somebody didn't put weird code on the server side.

Event-based attributes like `onclick` run Javascript code when you click on an element. Other ones e.g. `onmouseover` are triggered just by hovering a mouse pointer on them.

Iframes show any third-party HTML resource and thus include all the Javasctipt or CSS issues mentioned above.

In short words, unfiltered HTML is a huge security hole. You should never accept any HTML input untill you arm the server with tools to fiter it.

In this class, we'll talk mostly about sanitizing HTML data fetched from RSS feeds. Usualy they represent a teaser for a full blog post and consist from common HTML tags: headers, paragraps, links and images. For example:

```html
<img class="thumb-image" data-type="image" data-load="..."
  width="640" height="480"
  src="/images/articles/preview.jpg" />

<h1>Benchmark results</h1>

<p>This study compares computer performance across the following platforms:</p>

<ul>
  <li>Python</li>
  <li>Go</li>
  <li>Clojure</li>
</ul>

<table>
  <tbody>
    <thead>
      <tr>
        <th>Python</th>
        <th>Go</th>
        <th>Clojure</th>
      </tr>
    </thead>
  </tbody>
</table>

<a href="/articles/banchmark.html" data-load="...">Read more</a>
```

There is a bunch of problems in this sample, namely:

1. The image tag brings attributes that we don't need (`data-type`, `data-load`)
2. The same image has got width and height attributes which we don't need since
   the layout of your page differs from the origin.
3. The image is has got relative URL. If we show it on our server, it will
   either return 404 reponse or show another image.
4. Links suffer from the same issues: excess attributes, relative URL.
5. We don't want tables to appear in the text.
6. There should be a way to get bare text without any tags.
7. We should preserve iframes which reference YouTube embedded player.

To solve all of them, let's google for a stable, prooven Java library that deals with HTML.

## Starting with Jsoup

[owasp-site]:https://github.com/OWASP/java-html-sanitizer
[jsoup-site]:https://jsoup.org/

There is a couple of great HTML tools in Java world: [OWASP Java HTML Sanitizer][owasp-site] and [Jsoup][jsoup-site]. I've have worked with both of them and found the latter being a bit more friendly although it is a matter of personal choice. Jsoup can do a lot with HTML including sanitazion. We will go on with it through the session. Add the library into the project:

```clojure
:dependencies [[org.jsoup/jsoup "1.11.3"]]
```

Add a separate namespace so none of other modules interacts with Jsoup directly. Here is a draft:

```clojure
(ns project.sanitize
  (:import org.jsoup.Jsoup
           (org.jsoup.safety Whitelist Cleaner)
           (org.jsoup.nodes Element Document)))
```

These are all classes we need to complete the task.

You may sanitize documents with Jsoup in several ways. The simpliest one is to call static `clean` method with an HTML string and an instance of a `Whitelist` class:

```clojure
(defn sanitize-none
  [html]
  (when html
    (Jsoup/clean html (Whitelist/none))))
```

A whitelist is an entity that knows how to process tags and attributes. Out from the box, Jsoup ships several templates that cover most of the business requirements: `none`, `simpleText`, `basic`, `basicWithImages` and `relaxed`. Their naming demonstrates how HTML restrictions unwind to each level. For example, `none` template wipes all the tags leaving just bare text. The `simpleText` one keeps minor tags used mostly for text formatting, and so forth: more and more tags and attributes are allowed.

The function `sanitize-none` covers one of the requrements we've discussed before. It turns any HTML data to plain text that's great for preview widgets that do not allow HTML:

```clojure
(defn _text (sanitize-none html-sample))

TODO
```

Let's experiment a bit with another template:

```clojure
(defn sanitize-generic
  [whitelist html]
  (when html
    (Jsoup/clean html whitelist)))

(def sanitize-basic-images
  (partial sanitize-generic
           (Whitelist/basicWithImages)))

(sanitize-basic-images html-sample)
```

The result looks different: now some of HTML entities take their place. Pay
attention how did we declare `sanitize-basic-images` function. It's just partial
application of more generic `sanitize-generic`. Since the whole logic of a
function depends on a single parameter, it is fine to put it at the first place
and declare as many partials as you wish.

Although pre-defined whitelists are good, they cannot cover everything we
need. So let's consider the second low-level way of filtering HTML. First, let's
declare our own whitelist. We will do it in several steps.

Declare tags we'd like to keep, just a vector of strings:


```clojure

(def tags-allowed
  ["a"
   "b"
   "blockquote"
   "br"
   "code"
   "h1"
   "h2"
   "h3"
   "h4"
   "h5"
   "h6"
   "i"
   "iframe" ;; !!!
   "img"
   "li"
   "p"
   "pre"
   "small"
   "span"
   "strike"
   "strong"
   "sub"
   "sup"
   "u"
   "ul"])
```

A note opposite to `iframe` means this tag is dangerous and we're going to process it manually.

Declare what attributes we'd like to keep, a map of vectors:

```clojure
(def attrs-allowed
  {"img"    ["src"]
   "iframe" ["src" "allowfullscreen"]
   "a"      ["href"]})
```

Declare what network protocols. On the top level there is a tag name, then an
attribute and a list of network schemas:

```clojure
(def proto-allowed
  {"a"      {"href" ["http" "https" "mailto" "ftp"]}
   "img"    {"src"  ["http" "https"]}
   "iframe" {"src"  ["https"]}})
```

For example, a link might reference to an HTTP(s) and FTP resources or be an
email. But an iframe may only reference a secured `https://` resource.

A small wraper to convert a Clojure vector into typed Java array of Strings:

```clojure
(def ->array (partial into-array String))
```

Now that with all the data prepared we declare an instance of a `Whitelist`
class:

```clojure
(def ^Whitelist whitelist-custom
  (let [wl (new Whitelist)]

    ;; set tags
    (.addTags wl (->array tags-allowed))

    ;; set attributes
    (doseq [[tag attrs] attrs-allowed]
      (.addAttributes wl tag (->array attrs)))

    ;; set protocols
    (doseq [[tag mapping] proto-allowed]
      (doseq [[attr protocols] mapping]
        (.addProtocols wl tag attr (->array protocols))))

    wl))
```

What catches the eye here is Clojure code has become very imperative. That's
normal since we operate on Java ecosystem that is mostly imperative by its
nature.

Wrap the whitelist with a `Cleaner` class:

```clojure
(def ^Cleaner cleaner-custom
  (Cleaner. whitelist-custom))
```

Here is the function that cleans the source data using our own rules:

```clojure
(defn sanitize-custom
  [html page-url]
  (when html
    (let [page-url (or page-url "")
          ^Document doc-src (Jsoup/parse html page-url)]
      ;; (process-iframes doc-src)
      (let [^Document doc-out (.clean cleaner-custom doc-src)]
        (.. doc-out body html)))))
```

It accepts a raw HTML string and a URL and returns cleaned HTML string. We need
a source URL to fix relative links so the become absolute. For example, if the
source page was `http://example.com/pages/story` and there was an image with the
attribute `src="/images/something.jpeg"`, it becomes
`src="http://example.com/images/something.jpeg"` what is one of our busines
requirements.

The double dot macro acts like a chain of calls to the `doc-out`
varialbe. First, we receive its body which is an instance of an `Element`
class. Then we take its HTML content of that element as a string calling `html`
method.

Let's test the function:

```clojure
(sanitize-custom html-sample "http://example.com/pages/blog.html")
```

The result would be:

```html
TODO
```

This is nice, but we havent' dealt with iframes so far. There is commented line
in the function that signals we're about to fix that. Jsoup doesn't support
conditional statements for tags or attributes so we have to process iframes
manually.

Ok, let's uncomment that line and declare a draft version of a function:

```clojure
(defn process-iframes
  [^Document doc]
  (doseq [^Element el (.select doc "iframe")]
    ;; some logic goes here
    ))
```

Now let's discourse for a while. We need to keep only those iframes that
reference either YouTupe or Coub embedded players. For example:

```html

<iframe width="903" height="508" src="https://www.youtube.com/embed/OhadKfy2RxM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<iframe src="//coub.com/embed/5oy44?muted=false&autostart=false&originalSize=false&startWithHD=false" allowfullscreen frameborder="0" width="626" height="480" allow="autoplay"></iframe>
```

So logic would be to get a URL from the `src` attribute and match it against
regular expression. If it matches any of them, we keep that element in a DOM
three. When it doesn't, we remove it.

Declare the expressions and add some shortcuts:

```clojure
(def re-youtube
  #"(?i)youtube.com/embed")

(def re-coub
  #"(?i)coub.com/embed")

(defn media-src?
  [src]
  (or (re-find re-youtube src)
      (re-find re-coub src)))

(defn process-iframes
  [^Document doc]
  (doseq [^Element el (.select doc "iframe")]
    (let [src (.absUrl el "src")]
      (when-not (media-src? src)
        (.remove el)))))
```

That's it! So far, our code satisfies all the business requirements. Restricted
tags and attributes a wiped out. All the links and images addresses are
absolute. We preserve only those iframes that reference certain media resources:

```clojure
(sanitize-custom html-sample "http://example.com/pages/blog.html")
```

The result:

```html
TODO
```

Despite the exlanation was a bit log, the final code is suprisengly short. The
whole module takes just 100 lines:

```clojure
(ns project.san
  (:import org.jsoup.Jsoup
           (org.jsoup.safety Whitelist Cleaner)
           (org.jsoup.nodes Element Document)))


(def tags-allowed
  ["a" "b" "blockquote" "br" "code"
   "h1" "h2" "h3" "h4" "h5" "h6"
   "i" "iframe" "img" "li" "p" "pre"
   "small" "span" "strike" "strong"
   "sub" "sup" "u" "ul"])


(def attrs-allowed
  {"img"    ["src"]
   "iframe" ["src" "allowfullscreen"]
   "a"      ["href"]})


(def proto-allowed
  {"a"      {"href" ["http" "https" "mailto" "ftp"]}
   "img"    {"src"  ["http" "https"]}
   "iframe" {"src"  ["https"]}})


(def ->array (partial into-array String))


(def ^Whitelist whitelist-custom
  (let [wl (new Whitelist)]

    (.addTags wl (->array tags-allowed))

    (doseq [[tag attrs] attrs-allowed]
      (.addAttributes wl tag (->array attrs)))

    (doseq [[tag mapping] proto-allowed]
      (doseq [[attr protocols] mapping]
        (.addProtocols wl tag attr (->array protocols))))

    wl))


(def ^Cleaner cleaner-custom
  (Cleaner. whitelist-custom))


(def re-youtube
  #"(?i)youtube.com/embed")


(def re-coub
  #"(?i)coub.com/embed")


(defn media-src?
  [src]
  (or (re-find re-youtube src)
      (re-find re-coub src)))


(defn process-iframes
  [^Document doc]
  (doseq [^Element el (.select doc "iframe")]
    (let [src (.absUrl el "src")]
      (when-not (media-src? src)
        (.remove el)))))


(defn sanitize-custom
  [html page-url]
  (when html
    (let [page-url (or page-url "")
          ^Document doc-src (Jsoup/parse html page-url)]
      (process-iframes doc-src)
      (let [^Document doc-out (.clean cleaner-custom doc-src)]
        (.. doc-out body html)))))


(defn sanitize-generic
  [whitelist html]
  (when html
    (Jsoup/clean html whitelist)))


(def sanitize-none
  (partial sanitize-generic
           (Whitelist/none)))


(def sanitize-basic-images
  (partial sanitize-generic
           (Whitelist/basicWithImages)))
```

TODO GitHub link

You may look it through on GitHub.

My congratulations to you if you've been following the line to the end. So far,
we've learnt how to sanitize HTML reusing Java Jsoup library. The solution looks
solid and neet. It's easy to tweak in different prospectives. Most of the
configuration is stored in Clojure maps or vectors so allowing or restrictint
yet another tag would mean just to add or remove it from a collection. It's
declarative, as functional programmers tend to say. Processing an extra media
iframe, say Vimeo or VKontakte implies adding just one more regex expression.

To the end of the second class, I believe you've made sure how much power Java
brings to the scene. But the most part of the practial lessons are still ahead
of us.
